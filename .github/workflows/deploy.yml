# .github/workflows/deploy.yml
name: Deploy Raffley to VPS

env:
  MIX_ENV: prod
  # Define consistent names used across jobs
  RELEASE_NAME: raffley
  TAR_FILENAME: release.tar.gz
  # Specify Elixir/OTP versions once
  ELIXIR_VERSION: '1.18' # Or your specific version e.g., '1.18.0'
  OTP_VERSION: '27'      # Or your specific version e.g., '27.0'

# Required GitHub Secrets:
# - VPS_HOST: Hostname/IP of your VPS server
# - VPS_SSH_USER: SSH username for VPS access
# - VPS_SSH_PRIVATE_KEY: SSH private key (RAW content, NOT base64)
# - VPS_DEPLOY_PATH: Absolute path to the base deployment directory on VPS (e.g., /home/deploy/raffley)
# - SECRET_KEY_BASE: Phoenix secret key base (Needed on VPS runtime)
# - DATABASE_URL: Database connection string (Needed on VPS runtime)
# - RESEND_API_KEY: API key for Resend email service (Needed on VPS runtime)
# - PHX_HOST: Hostname for the application (Needed on VPS runtime)

on:
  push:
    branches: [main]

jobs:
  build:
    name: Build Release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Elixir
        uses: erlef/setup-beam@v1
        with:
          elixir-version: ${{ env.ELIXIR_VERSION }}
          otp-version: ${{ env.OTP_VERSION }}

      - name: Cache Mix dependencies
        id: mix-cache # Give cache step an ID
        uses: actions/cache@v4
        with:
          path: |
            deps
            _build
          key: ${{ runner.os }}-mix-${{ hashFiles('**/mix.lock') }}
          restore-keys: |
            ${{ runner.os }}-mix-

      - name: Install Mix dependencies
        # Only run if cache missed to speed up builds
        if: steps.mix-cache.outputs.cache-hit != 'true'
        run: mix deps.get --only prod

      # Optional: Compile assets if your project requires it before release
      # - name: Install Node.js (if needed for assets)
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: '20' # Specify your Node.js version
      #     cache: 'npm'
      #     cache-dependency-path: 'assets/package-lock.json' # Adjust path if needed
      # - name: Install Node dependencies
      #   run: npm ci --prefix assets # Adjust path if needed
      # - name: Compile assets
      #   run: mix assets.deploy

      - name: Build release
        # Pass secrets needed ONLY at build time here if necessary
        # env:
        #   SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }} # Example
        run: mix release --overwrite

      - name: Archive release artifact
        run: |
          RELEASE_BUILD_PATH="_build/prod/rel/${{ env.RELEASE_NAME }}"
          tar -czf ${{ env.TAR_FILENAME }} -C "$RELEASE_BUILD_PATH" .
          echo "Created artifact: ${{ env.TAR_FILENAME }}"

      - name: Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.RELEASE_NAME }}-release-artifact # Use a descriptive name
          path: ${{ env.TAR_FILENAME }}
          retention-days: 1 # Keep artifacts for 1 day

  deploy:
    name: Deploy to VPS
    needs: build # Run only after the build job succeeds
    runs-on: ubuntu-latest

    steps:
      - name: Validate Secrets Presence
        run: |
          echo "Checking required secrets..."
          if [ -z "${{ secrets.VPS_HOST }}" ]; then echo "Error: VPS_HOST secret missing"; exit 1; fi
          if [ -z "${{ secrets.VPS_SSH_USER }}" ]; then echo "Error: VPS_SSH_USER secret missing"; exit 1; fi
          if [ -z "${{ secrets.VPS_SSH_PRIVATE_KEY }}" ]; then echo "Error: VPS_SSH_PRIVATE_KEY secret missing"; exit 1; fi
          if [ -z "${{ secrets.VPS_DEPLOY_PATH }}" ]; then echo "Error: VPS_DEPLOY_PATH secret missing"; exit 1; fi
          echo "Required deployment secrets seem present."
          echo "Note: Runtime secrets (SECRET_KEY_BASE, DATABASE_URL, etc.) must be configured on the VPS."

      - name: Download release artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.RELEASE_NAME }}-release-artifact # Match the upload name
          # Downloads to the current directory by default

      - name: List downloaded files # Debug step
        run: ls -lh

      - name: Deploy release to server via SCP
        uses: appleboy/scp-action@v0.1.7 # Use specific version
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_SSH_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }} # IMPORTANT: Use the RAW private key content, NOT base64 encoded
          # port: ${{ secrets.SSH_PORT || 22 }} # Uncomment and set secret if using non-standard port
          source: ${{ env.TAR_FILENAME }}
          target: "/tmp" # Copy artifact to a temporary location on the VPS

      - name: Execute remote deployment commands
        uses: appleboy/ssh-action@v1.0.3 # Use specific version
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_SSH_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }} # IMPORTANT: Use the RAW private key content
          # port: ${{ secrets.SSH_PORT || 22 }} # Uncomment if needed
          script: |
            set -e # Exit immediately if a command exits with a non-zero status. Helps catch errors early.

            # --- Configuration ---
            # Use secrets/env vars passed from the workflow
            DEPLOY_BASE_PATH="${{ secrets.VPS_DEPLOY_PATH }}" # e.g., /home/deploy/raffley
            RELEASE_NAME="${{ env.RELEASE_NAME }}"           # e.g., raffley
            TAR_FILENAME="${{ env.TAR_FILENAME }}"           # e.g., release.tar.gz
            # Define paths on the remote server
            REMOTE_TMP_TAR_PATH="/tmp/$TAR_FILENAME"         # Where SCP placed the file
            RELEASES_DIR="$DEPLOY_BASE_PATH/releases"        # Directory to store versioned releases
            CURRENT_RELEASE_DIR="$RELEASES_DIR/$(date +%Y%m%d%H%M%S)" # Unique dir for this deployment
            CURRENT_SYMLINK="$DEPLOY_BASE_PATH/current"      # Symlink pointing to the active release
            SERVICE_NAME="$RELEASE_NAME.service"             # Assumed systemd service name

            echo "--- Deployment Started ---"
            echo "Deploy Base Path: $DEPLOY_BASE_PATH"
            echo "Release Name: $RELEASE_NAME"
            echo "Target Release Dir: $CURRENT_RELEASE_DIR"
            echo "Service Name: $SERVICE_NAME"
            echo "Remote Tarball Path: $REMOTE_TMP_TAR_PATH"

            echo "1. Creating directories..."
            mkdir -p "$CURRENT_RELEASE_DIR"

            echo "2. Extracting release from $REMOTE_TMP_TAR_PATH to $CURRENT_RELEASE_DIR..."
            tar -xzf "$REMOTE_TMP_TAR_PATH" -C "$CURRENT_RELEASE_DIR"

            echo "3. Removing temporary tarball..."
            rm "$REMOTE_TMP_TAR_PATH"

            # --- Runtime Environment Setup ---
            # IMPORTANT: Ensure your runtime secrets (DATABASE_URL, SECRET_KEY_BASE, etc.)
            # are available to the application here. Common methods:
            # a) Systemd EnvironmentFile=: Point service file to an env file.
            # b) .env file: Create a .env file in $CURRENT_RELEASE_DIR or $DEPLOY_BASE_PATH
            #    and modify the release start script (`bin/raffley`) or systemd service
            #    to source it. Example for .env file:
            # echo "Creating .env file (ensure secrets are configured on VPS)..."
            # ENV_FILE_PATH="$DEPLOY_BASE_PATH/.env" # Or $CURRENT_RELEASE_DIR/.env
            # touch "$ENV_FILE_PATH" # Create if not exists
            # chmod 600 "$ENV_FILE_PATH" # Secure permissions
            # You would typically manage the content of this file outside the deploy script
            # or securely copy/generate it.

            echo "4. Running database migrations..."
            # Use the specific path to the executable in the newly extracted release
            # The necessary ENV VARS (like DATABASE_URL) must be available for this command
            "$CURRENT_RELEASE_DIR/bin/$RELEASE_NAME" eval "Raffley.Release.migrate"

            echo "5. Updating current release symlink..."
            ln -sfn "$CURRENT_RELEASE_DIR" "$CURRENT_SYMLINK"

            # Optional: Set ownership if your app runs as a different user
            # DEPLOY_USER=$(whoami) # Or specify the user e.g., 'www-data'
            # sudo chown -R $DEPLOY_USER:$DEPLOY_USER "$CURRENT_RELEASE_DIR"
            # sudo chown -h $DEPLOY_USER:$DEPLOY_USER "$CURRENT_SYMLINK" # -h for symlink itself

            echo "6. Restarting service ($SERVICE_NAME)..."
            # Use restart instead of stop/start for smoother transition if possible
            sudo systemctl restart "$SERVICE_NAME"

            echo "7. Verifying service status..."
            sleep 5 # Give the service a moment to stabilize
            if sudo systemctl is-active --quiet "$SERVICE_NAME"; then
              echo "✅ Service '$SERVICE_NAME' is active."
            else
              echo "❌ Service '$SERVICE_NAME' failed to start!"
              echo "Check logs on the server: sudo journalctl -u $SERVICE_NAME -n 50 --no-pager"
              exit 1 # Fail the deployment step
            fi

            # Optional: Cleanup old releases (keep last 3)
            echo "8. Cleaning up old releases (keeping last 3)..."
            cd "$RELEASES_DIR" && ls -t | tail -n +4 | xargs --no-run-if-empty sudo rm -rf

            echo "--- Deployment Successful ---"

      # Optional: Add more specific notification steps
      - name: Notify Success
        if: success()
        run: echo "✅ Deployment to ${{ secrets.VPS_HOST }} completed successfully."

      - name: Notify Failure
        if: failure()
        run: echo "❌ Deployment to ${{ secrets.VPS_HOST }} failed."
